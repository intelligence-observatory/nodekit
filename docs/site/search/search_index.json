{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to NodeKit","text":""},{"location":"#install-nodekit","title":"Install NodeKit","text":""},{"location":"efsm/","title":"NodeKit Types","text":""},{"location":"efsm/#values-and-expressions","title":"Values and Expressions","text":"<ul> <li><code>Value</code>. Sum type of <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>list[Value]</code>, <code>dict[str, Value]</code>.</li> <li><code>Expression&lt;V&gt;</code>. A computation the interpreter may evaluate to a Value of type <code>V</code>, discriminated by <code>op</code>. Notable forms:<ul> <li>Data access: <code>reg</code>, <code>local</code>, <code>la</code> (last action), <code>gli</code> (get list item), <code>gdv</code> (get dict value), <code>lit</code>.</li> <li>Conditionals and logic: <code>if</code>, <code>not</code>, variadic <code>or</code>/<code>and</code>.</li> <li>Comparators: <code>eq</code>, <code>ne</code>, <code>gt</code>, <code>ge</code>, <code>lt</code>, <code>le</code>.</li> <li>Arithmetic: <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>.</li> <li>Array ops: <code>slice</code>, <code>map</code>, <code>filter</code>, <code>fold</code> (with local bindings for <code>cur</code>/<code>acc</code> where relevant).</li> </ul> </li> </ul>"},{"location":"efsm/#graph","title":"Graph","text":"<p>A Graph describes a behavioral task as an extended finite state machine. The Graph consists of Nodes, the Transitions between them, and a Register file.   - <code>.start: NodeId</code>. The starting Node of the task.   - <code>.nodes: Dict[NodeId, Node]</code>. Nodes are the vertices of the Graph. A <code>Node</code> is a description of an atomic unit of an experiment. It is described in further detail below.   - <code>.transitions: Dict[NodeId, Transition]</code>. A Transition describes the outgoing edge(s) from each Node. <code>Transition</code> is a sum type: <code>Go | End | IfThenElse | Switch</code>.     - <code>Go { to: NodeId, register_updates?: Dict[RegisterId, Expression] }</code>     - <code>End {}</code> (terminates the Graph)     - <code>IfThenElse { if: Expression&lt;bool&gt;, then: Go | End, else: Go | End }</code> (binary guard; <code>else_</code> defaults to <code>End</code>)     - <code>Switch { on: Expression&lt;LeafValue&gt;, cases: Dict[LeafValue, Go | End], default?: Go | End }</code> (value-based dispatch; no fallthrough, <code>default</code> defaults to <code>End</code>)     - <code>register_updates</code> live only on <code>Go</code> (including those nested inside <code>IfThenElse</code>/<code>Switch</code> branches). All Expressions are evaluated before any are committed.   - <code>.registers: Dict[RegisterId, Value]</code>. The initial register file of the EFSM.</p>"},{"location":"efsm/#trace","title":"Trace","text":"<p>A <code>Trace</code> is a description of a single Agent's run of a Graph.   - <code>.events: Event[]</code>. Raw log of everything that happened across the run (e.g. pointer, key, sensor-triggered actions). Events are stored sorted by timestamp. </p>"},{"location":"efsm/#node","title":"Node","text":"<p>A Node consists of a single <code>Stimulus</code> and a single <code>Sensor</code>. Conceptually:  * the <code>Stimulus</code> describes the context provided to the Agent (e.g. an image, a pair of images, a video and a piece of text...).  * the <code>Sensor</code> describes the action set (and associated selection procedure) that the Agent will be presented with in the Node.</p> <p>A Node ends when the Sensor is triggered by an <code>Action</code>.</p> <p>Additional presentation/behavior fields: * <code>board_color</code>: background color for the Node (defaults to <code>#808080ff</code>). * <code>hide_pointer</code>: whether to hide the pointer during this Node.</p>"},{"location":"efsm/#stimulus","title":"Stimulus","text":"<p>A <code>Stimulus</code> is described using a type called a <code>Card</code>. </p>"},{"location":"efsm/#card","title":"Card","text":"<p>Cards represent a visual element on the Board. There are four Card types in NodeKit:  * <code>ImageCard</code> * <code>VideoCard</code> * <code>TextCard</code> * <code>CompositeCard</code>, which is a container that can contain other Cards.</p>"},{"location":"efsm/#sensor","title":"Sensor","text":"<p>Sensors are state machines which hold a Sensor state. They \"fire\" once with an Action, then are disabled after. Leaf Sensors:</p> <ul> <li><code>WaitSensor</code> \u2014 fires after <code>duration_msec</code>.</li> <li><code>ClickSensor</code> \u2014 fires on a pointer click within <code>region</code>.</li> <li><code>KeySensor</code> \u2014 fires on the first valid key in <code>keys</code>.</li> <li><code>SelectSensor</code> \u2014 fires on the first choice selection.</li> <li><code>MultiSelectSensor</code> \u2014 fires when the <code>confirm_button</code> is pressed after meeting <code>min_selections</code>/<code>max_selections</code> constraints.</li> <li><code>SliderSensor</code> \u2014 fires when the first slider value is set (<code>num_bins</code>, <code>initial_bin_index</code>, optional <code>show_bin_markers</code>, <code>orientation</code>).</li> <li><code>TextEntrySensor</code> \u2014 fires on Done after a valid text entry (<code>prompt</code>, <code>font_size</code>, <code>min_length</code>, optional <code>max_length</code>).</li> </ul> <p>Composite Sensors: * <code>ProductSensor</code> \u2014 product of child action sets. * <code>SumSensor</code> \u2014 disjoint union; the first child to fire wins.</p> <p><code>type Sensor = LeafSensor | Product&lt;Sensor&gt; | Sum&lt;Sensor&gt;</code></p>"},{"location":"efsm/#board","title":"Board","text":"<p>The Board is the square region of the Participant's display on which the Graph unfolds. Points on the Board are given using Board coordinates, where (0, 0) is the center of the Board and (0.5, 0.5) is the top right.</p> <p>NodeKit defines the ideal Board as 768 x 768 reference pixels. A reference pixel is a unit of visual angle defined in the W3C specification as the visual angle of one pixel on a device with 96 dpi at an arm's length. Given an arm's length of 28 inches, a reference pixel is ~0.0213\u00b0 of visual angle, and the Board is ~16.26\u00b0 x 16.26\u00b0 of the Participant's visual field when viewed straight on.</p> <p>In practice, NodeKit sets the Board to 768 x 768 CSS pixels, which the W3C spec recommends be mapped by the browser 1:1 with reference pixels. Note that this mapping is always approximate, in that the browser 1) does not know the Participant's viewing position, and 2) does not know the physical size of device pixels.</p>"},{"location":"getting-started/","title":"Tutorial","text":""},{"location":"getting-started/#write-your-first-task","title":"Write your first task","text":""},{"location":"getting-started/#play-your-task-locally","title":"Play your task locally","text":""},{"location":"getting-started/#deploy-to-humans","title":"Deploy to humans","text":""},{"location":"getting-started/#deploy-to-models","title":"Deploy to models","text":""},{"location":"markdown/","title":"Markdown in NodeKit","text":"<p>NodeKit supports a defined subset of CommonMark for TextCards. Only the syntax below is supported; unsupported constructs might lead to runtime errors or strange rendering behaviors. </p>"},{"location":"markdown/#whats-supported","title":"What\u2019s supported","text":"<ul> <li>Headers: <code>#</code> through <code>######</code> followed by a space and text (levels above 6 are rejected).</li> <li>Italics: use <code>*text*</code> or <code>_text_</code>; </li> <li>Bolding: use <code>**text**</code> or <code>__text__</code>; </li> <li>Italics+Bolding: use <code>***text***</code> (and equivalents).</li> <li>Paragraphs: separate with a blank line; <code>&lt;br&gt;</code> is not supported. Soft line breaks are folded into spaces; hard breaks are not allowed.</li> <li>Lists: unordered bullets using any marker (<code>-</code>, <code>*</code>, <code>+</code>, etc.); ordered lists with <code>1.</code>. </li> <li>Color spans: <code>&lt;span style=\"color:#rrggbb\"&gt;text&lt;/span&gt;</code> or <code>#rrggbbaa</code>.  No other inline HTML or style attributes.</li> </ul>"},{"location":"markdown/#whats-not-supported","title":"What\u2019s not supported","text":"<p>Any other CommonMark features are not supported, including: - Inline code or fenced code blocks (single or triple backticks) - Links and images - Blockquotes, tables, and other Markdown extensions - Any HTML beyond the color <code>&lt;span&gt;</code> above</p>"},{"location":"markdown/#example","title":"Example","text":"<pre><code># Heading\n\nThis is a paragraph with **bold** and _italic_ text.\n\n- First item\n    - Nested item\n- Second item\n\n* Same list, different marker\n\nHere is &lt;span style=\"color:#ff00ff\"&gt;magenta text&lt;/span&gt;.\n</code></pre>"},{"location":"api/cards/","title":"Cards","text":""},{"location":"api/cards/#nodekit.cards.TextCard","title":"nodekit.cards.TextCard  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>card_type</code>                 (<code>Literal['TextCard']</code>)             </li> <li> <code>text</code>                 (<code>MarkdownString</code>)             </li> <li> <code>font_size</code>                 (<code>SpatialSize</code>)             </li> <li> <code>justification_horizontal</code>                 (<code>Literal['left', 'center', 'right']</code>)             </li> <li> <code>justification_vertical</code>                 (<code>Literal['top', 'center', 'bottom']</code>)             </li> <li> <code>text_color</code>                 (<code>ColorHexString</code>)             </li> <li> <code>background_color</code>                 (<code>ColorHexString</code>)             </li> <li> <code>region</code>                 (<code>Region</code>)             </li> </ul>"},{"location":"api/cards/#nodekit.cards.TextCard.background_color","title":"background_color  <code>pydantic-field</code>","text":"<pre><code>background_color: ColorHexString = '#E6E6E600'\n</code></pre> <p>The background color of the TextCard in hexadecimal format.</p>"},{"location":"api/cards/#nodekit.cards.TextCard.font_size","title":"font_size  <code>pydantic-field</code>","text":"<pre><code>font_size: SpatialSize = 0.02\n</code></pre> <p>The height of the em-box, in Board units.</p>"},{"location":"api/cards/#nodekit.cards.ImageCard","title":"nodekit.cards.ImageCard  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>card_type</code>                 (<code>Literal['ImageCard']</code>)             </li> <li> <code>image</code>                 (<code>Image</code>)             </li> <li> <code>region</code>                 (<code>Region</code>)             </li> </ul>"},{"location":"api/cards/#nodekit.cards.VideoCard","title":"nodekit.cards.VideoCard  <code>pydantic-model</code>","text":"<p>Video stimulus placed on the Board.</p> <p>Attributes:</p> <ul> <li> <code>video</code>               (<code>Video</code>)           \u2013            <p>The video asset to render.</p> </li> <li> <code>loop</code>               (<code>bool</code>)           \u2013            <p>Whether to loop the video when it ends.</p> </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            <p>The Board region where the video is rendered.</p> </li> </ul> <p>Fields:</p> <ul> <li> <code>card_type</code>                 (<code>Literal['VideoCard']</code>)             </li> <li> <code>video</code>                 (<code>Video</code>)             </li> <li> <code>loop</code>                 (<code>bool</code>)             </li> <li> <code>region</code>                 (<code>Region</code>)             </li> </ul>"},{"location":"api/cards/#nodekit.cards.VideoCard.loop","title":"loop  <code>pydantic-field</code>","text":"<pre><code>loop: bool = False\n</code></pre> <p>Whether to loop the video when it ends.</p>"},{"location":"api/cards/#nodekit.cards.CompositeCard","title":"nodekit.cards.CompositeCard  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>card_type</code>                 (<code>Literal['CompositeCard']</code>)             </li> <li> <code>children</code>                 (<code>Dict[str, Card]</code>)             </li> </ul>"},{"location":"api/expressions/","title":"Expressions","text":""},{"location":"api/expressions/#nodekit.expressions.Reg","title":"nodekit.expressions.Reg  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['reg']</code>)             </li> <li> <code>id</code>                 (<code>RegisterId</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Local","title":"nodekit.expressions.Local  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['local']</code>)             </li> <li> <code>name</code>                 (<code>LocalVariableName</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.LastAction","title":"nodekit.expressions.LastAction  <code>pydantic-model</code>","text":"<p>Evaluates to the last completed Node's Action.</p> <p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['la']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.GetListItem","title":"nodekit.expressions.GetListItem  <code>pydantic-model</code>","text":"<p>Get an element from a container (Array or Struct). <code>container</code> must evaluate to an array- or struct-valued result.</p> <p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['gli']</code>)             </li> <li> <code>list</code>                 (<code>Expression</code>)             </li> <li> <code>index</code>                 (<code>Expression</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.GetDictValue","title":"nodekit.expressions.GetDictValue  <code>pydantic-model</code>","text":"<p>Get a value from a dictionary by key. <code>dict</code> must evaluate to a dict-valued result.</p> <p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['gdv']</code>)             </li> <li> <code>d</code>                 (<code>Expression</code>)             </li> <li> <code>key</code>                 (<code>Expression</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.GetDictValue.d","title":"d  <code>pydantic-field</code>","text":"<pre><code>d: Expression\n</code></pre> <p>Evaluates to a Dict.</p>"},{"location":"api/expressions/#nodekit.expressions.Lit","title":"nodekit.expressions.Lit  <code>pydantic-model</code>","text":"<p>Literal value.</p> <p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['lit']</code>)             </li> <li> <code>value</code>                 (<code>Value</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.If","title":"nodekit.expressions.If  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['if']</code>)             </li> <li> <code>cond</code>                 (<code>Expression</code>)             </li> <li> <code>then</code>                 (<code>Expression</code>)             </li> <li> <code>otherwise</code>                 (<code>Expression</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Not","title":"nodekit.expressions.Not  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['not']</code>)             </li> <li> <code>operand</code>                 (<code>Expression</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Or","title":"nodekit.expressions.Or  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['or']</code>)             </li> <li> <code>args</code>                 (<code>list[Expression]</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.And","title":"nodekit.expressions.And  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>op</code>                 (<code>Literal['and']</code>)             </li> <li> <code>args</code>                 (<code>list[Expression]</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Eq","title":"nodekit.expressions.Eq  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['eq']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Ne","title":"nodekit.expressions.Ne  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['ne']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Gt","title":"nodekit.expressions.Gt  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['gt']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Ge","title":"nodekit.expressions.Ge  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['ge']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Lt","title":"nodekit.expressions.Lt  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['lt']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Le","title":"nodekit.expressions.Le  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['le']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Add","title":"nodekit.expressions.Add  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['add']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Sub","title":"nodekit.expressions.Sub  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['sub']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Mul","title":"nodekit.expressions.Mul  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['mul']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Div","title":"nodekit.expressions.Div  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>lhs</code>                 (<code>Expression</code>)             </li> <li> <code>rhs</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['div']</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Slice","title":"nodekit.expressions.Slice  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>array</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['slice']</code>)             </li> <li> <code>start</code>                 (<code>Expression</code>)             </li> <li> <code>end</code>                 (<code>Optional[Expression]</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Map","title":"nodekit.expressions.Map  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>array</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['map']</code>)             </li> <li> <code>cur</code>                 (<code>LocalVariableName</code>)             </li> <li> <code>func</code>                 (<code>Expression</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Filter","title":"nodekit.expressions.Filter  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>array</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['filter']</code>)             </li> <li> <code>cur</code>                 (<code>LocalVariableName</code>)             </li> <li> <code>predicate</code>                 (<code>Expression</code>)             </li> </ul>"},{"location":"api/expressions/#nodekit.expressions.Fold","title":"nodekit.expressions.Fold  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>array</code>                 (<code>Expression</code>)             </li> <li> <code>op</code>                 (<code>Literal['fold']</code>)             </li> <li> <code>init</code>                 (<code>Expression</code>)             </li> <li> <code>acc</code>                 (<code>LocalVariableName</code>)             </li> <li> <code>cur</code>                 (<code>LocalVariableName</code>)             </li> <li> <code>func</code>                 (<code>Expression</code>)             </li> </ul>"},{"location":"api/graph/","title":"Graph","text":"<p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['Graph']</code>)             </li> <li> <code>nodekit_version</code>                 (<code>Literal['0.2.0']</code>)             </li> <li> <code>nodes</code>                 (<code>Dict[NodeId, Union[Node, Graph]]</code>)             </li> <li> <code>transitions</code>                 (<code>Dict[NodeId, Transition]</code>)             </li> <li> <code>start</code>                 (<code>NodeId</code>)             </li> <li> <code>registers</code>                 (<code>Dict[RegisterId, Value]</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>check_graph_is_valid</code> </li> </ul>"},{"location":"api/graph/#transitions","title":"Transitions","text":""},{"location":"api/graph/#nodekit.transitions.Go","title":"nodekit.transitions.Go  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>transition_type</code>                 (<code>Literal['Go']</code>)             </li> <li> <code>to</code>                 (<code>NodeId</code>)             </li> <li> <code>register_updates</code>                 (<code>Dict[RegisterId, Expression]</code>)             </li> </ul>"},{"location":"api/graph/#nodekit.transitions.End","title":"nodekit.transitions.End  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>transition_type</code>                 (<code>Literal['End']</code>)             </li> </ul>"},{"location":"api/graph/#nodekit.transitions.IfThenElse","title":"nodekit.transitions.IfThenElse  <code>pydantic-model</code>","text":"<p>Config:</p> <ul> <li><code>serialize_by_alias</code>: <code>True</code></li> <li><code>validate_by_alias</code>: <code>False</code></li> <li><code>populate_by_name</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>transition_type</code>                 (<code>Literal['IfThenElse']</code>)             </li> <li> <code>if_</code>                 (<code>Annotated[Expression, Field(serialization_alias='if', validation_alias='if', description='A boolean-valued Expression.')]</code>)             </li> <li> <code>then</code>                 (<code>LeafTransition</code>)             </li> <li> <code>else_</code>                 (<code>Annotated[LeafTransition, Field(default_factory=End, validate_default=True, alias='else')]</code>)             </li> </ul>"},{"location":"api/graph/#nodekit.transitions.Switch","title":"nodekit.transitions.Switch  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>transition_type</code>                 (<code>Literal['Switch']</code>)             </li> <li> <code>on</code>                 (<code>Expression</code>)             </li> <li> <code>cases</code>                 (<code>Dict[LeafValue, LeafTransition]</code>)             </li> <li> <code>default</code>                 (<code>LeafTransition</code>)             </li> </ul>"},{"location":"api/graph/#nodekit.transitions.Switch.default","title":"default  <code>pydantic-field</code>","text":"<pre><code>default: LeafTransition\n</code></pre> <p>The transition to take if no case matches.</p>"},{"location":"api/node/","title":"Node","text":""},{"location":"api/node/#nodekit.Node","title":"nodekit.Node  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['Node']</code>)             </li> <li> <code>stimulus</code>                 (<code>Card | None</code>)             </li> <li> <code>sensor</code>                 (<code>Sensor</code>)             </li> <li> <code>board_color</code>                 (<code>ColorHexString</code>)             </li> <li> <code>hide_pointer</code>                 (<code>bool</code>)             </li> </ul>"},{"location":"api/node/#nodekit.Node.board_color","title":"board_color  <code>pydantic-field</code>","text":"<pre><code>board_color: ColorHexString = '#808080ff'\n</code></pre> <p>The color of the Board during this Node (the \"background color\").</p>"},{"location":"api/ops/","title":"Ops","text":""},{"location":"api/ops/#nodekit.play","title":"nodekit.play","text":"<pre><code>play(graph: Graph) -&gt; Trace\n</code></pre> <p>Play the given Graph locally, then return the Trace.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>x</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trace</code>           \u2013            <p>The Trace of Events observed during execution.</p> </li> </ul>"},{"location":"api/sensors/","title":"Sensors","text":""},{"location":"api/sensors/#nodekit.sensors.SelectSensor","title":"nodekit.sensors.SelectSensor  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>sensor_type</code>                 (<code>Literal['SelectSensor']</code>)             </li> <li> <code>choices</code>                 (<code>Dict[str, Card]</code>)             </li> </ul>"},{"location":"api/sensors/#nodekit.sensors.MultiSelectSensor","title":"nodekit.sensors.MultiSelectSensor  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>sensor_type</code>                 (<code>Literal['MultiSelectSensor']</code>)             </li> <li> <code>choices</code>                 (<code>Dict[str, Card]</code>)             </li> <li> <code>min_selections</code>                 (<code>int</code>)             </li> <li> <code>max_selections</code>                 (<code>int | None</code>)             </li> <li> <code>confirm_button</code>                 (<code>Card</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>validate_selections_vals</code> </li> </ul>"},{"location":"api/sensors/#nodekit.sensors.MultiSelectSensor.max_selections","title":"max_selections  <code>pydantic-field</code>","text":"<pre><code>max_selections: int | None = None\n</code></pre> <p>If None, the selection can contain up to the number of available Cards.</p>"},{"location":"api/sensors/#nodekit.sensors.MultiSelectSensor.min_selections","title":"min_selections  <code>pydantic-field</code>","text":"<pre><code>min_selections: int\n</code></pre> <p>The minimum number of Cards before the Sensor fires.</p>"},{"location":"api/sensors/#nodekit.sensors.SliderSensor","title":"nodekit.sensors.SliderSensor  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>sensor_type</code>                 (<code>Literal['SliderSensor']</code>)             </li> <li> <code>num_bins</code>                 (<code>int</code>)             </li> <li> <code>initial_bin_index</code>                 (<code>int</code>)             </li> <li> <code>show_bin_markers</code>                 (<code>bool</code>)             </li> <li> <code>orientation</code>                 (<code>Literal['horizontal', 'vertical']</code>)             </li> <li> <code>region</code>                 (<code>Region</code>)             </li> </ul>"},{"location":"api/sensors/#nodekit.sensors.TextEntrySensor","title":"nodekit.sensors.TextEntrySensor  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>sensor_type</code>                 (<code>Literal['TextEntrySensor']</code>)             </li> <li> <code>prompt</code>                 (<code>str</code>)             </li> <li> <code>font_size</code>                 (<code>SpatialSize</code>)             </li> <li> <code>min_length</code>                 (<code>int</code>)             </li> <li> <code>max_length</code>                 (<code>int | None</code>)             </li> <li> <code>region</code>                 (<code>Region</code>)             </li> </ul>"},{"location":"api/sensors/#nodekit.sensors.TextEntrySensor.font_size","title":"font_size  <code>pydantic-field</code>","text":"<pre><code>font_size: SpatialSize = 0.02\n</code></pre> <p>The height of the em-box, in Board units.</p>"},{"location":"api/sensors/#nodekit.sensors.TextEntrySensor.max_length","title":"max_length  <code>pydantic-field</code>","text":"<pre><code>max_length: int | None = None\n</code></pre> <p>The maximum number of characters the user can enter. If None, no limit.</p>"},{"location":"api/sensors/#nodekit.sensors.TextEntrySensor.min_length","title":"min_length  <code>pydantic-field</code>","text":"<pre><code>min_length: int = 1\n</code></pre> <p>The minimum number of characters the user must enter before the Sensor fires. If None, no limit.</p>"},{"location":"api/sensors/#nodekit.sensors.TextEntrySensor.prompt","title":"prompt  <code>pydantic-field</code>","text":"<pre><code>prompt: str = ''\n</code></pre> <p>The initial placeholder text shown in the free text response box. It disappears when the user selects the element.</p>"},{"location":"api/sensors/#nodekit.sensors.WaitSensor","title":"nodekit.sensors.WaitSensor  <code>pydantic-model</code>","text":"<p>A Sensor that triggers when the specified time has elapsed since the start of the Node.</p> <p>Fields:</p> <ul> <li> <code>sensor_type</code>                 (<code>Literal['WaitSensor']</code>)             </li> <li> <code>duration_msec</code>                 (<code>TimeDurationMsec</code>)             </li> </ul>"},{"location":"api/sensors/#nodekit.sensors.WaitSensor.duration_msec","title":"duration_msec  <code>pydantic-field</code>","text":"<pre><code>duration_msec: TimeDurationMsec\n</code></pre> <p>The number of milliseconds from the start of the Node when the Sensor triggers.</p>"},{"location":"api/sensors/#nodekit.sensors.ProductSensor","title":"nodekit.sensors.ProductSensor  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>sensor_type</code>                 (<code>Literal['ProductSensor']</code>)             </li> <li> <code>children</code>                 (<code>Dict[str, Sensor]</code>)             </li> </ul>"},{"location":"api/sensors/#nodekit.sensors.SumSensor","title":"nodekit.sensors.SumSensor  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>sensor_type</code>                 (<code>Literal['SumSensor']</code>)             </li> <li> <code>children</code>                 (<code>Dict[str, Sensor]</code>)             </li> </ul>"},{"location":"api/trace/","title":"Trace","text":"<p>Fields:</p> <ul> <li> <code>nodekit_version</code>                 (<code>Literal['0.2.0']</code>)             </li> <li> <code>events</code>                 (<code>list[Event]</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>order_events</code>                 \u2192                   <code>events</code> </li> </ul>"},{"location":"api/trace/#events","title":"Events","text":""},{"location":"api/trace/#nodekit.events.TraceStartedEvent","title":"nodekit.events.TraceStartedEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[TraceStartedEvent]</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.TraceEndedEvent","title":"nodekit.events.TraceEndedEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[TraceEndedEvent]</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.NodeStartedEvent","title":"nodekit.events.NodeStartedEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>node_id</code>                 (<code>NodeId</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[NodeStartedEvent]</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.ActionTakenEvent","title":"nodekit.events.ActionTakenEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>node_id</code>                 (<code>NodeId</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[ActionTakenEvent]</code>)             </li> <li> <code>action</code>                 (<code>Action</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.NodeEndedEvent","title":"nodekit.events.NodeEndedEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>node_id</code>                 (<code>NodeId</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[NodeEndedEvent]</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.KeySampledEvent","title":"nodekit.events.KeySampledEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[KeySampledEvent]</code>)             </li> <li> <code>key</code>                 (<code>str</code>)             </li> <li> <code>kind</code>                 (<code>Literal['down', 'up']</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.PointerSampledEvent","title":"nodekit.events.PointerSampledEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[PointerSampledEvent]</code>)             </li> <li> <code>x</code>                 (<code>SpatialPoint</code>)             </li> <li> <code>y</code>                 (<code>SpatialPoint</code>)             </li> <li> <code>kind</code>                 (<code>Literal['move', 'down', 'up']</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.PageSuspendedEvent","title":"nodekit.events.PageSuspendedEvent  <code>pydantic-model</code>","text":"<p>Emitted when a Participant suspends the page (e.g., closes the tab or navigates away).</p> <p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[PageSuspendedEvent]</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.PageResumedEvent","title":"nodekit.events.PageResumedEvent  <code>pydantic-model</code>","text":"<p>Emitted when a Participant returns to the page (e.g., reopens the tab or navigates back).</p> <p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[PageResumedEvent]</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.BrowserContextSampledEvent","title":"nodekit.events.BrowserContextSampledEvent  <code>pydantic-model</code>","text":"<p>Fields:</p> <ul> <li> <code>t</code>                 (<code>TimeElapsedMsec</code>)             </li> <li> <code>event_type</code>                 (<code>Literal[BrowserContextSampledEvent]</code>)             </li> <li> <code>user_agent</code>                 (<code>str</code>)             </li> <li> <code>timestamp_client</code>                 (<code>str</code>)             </li> <li> <code>device_pixel_ratio</code>                 (<code>float</code>)             </li> <li> <code>display</code>                 (<code>RegionSizePx</code>)             </li> <li> <code>viewport</code>                 (<code>RegionSizePx</code>)             </li> </ul>"},{"location":"api/trace/#nodekit.events.BrowserContextSampledEvent.device_pixel_ratio","title":"device_pixel_ratio  <code>pydantic-field</code>","text":"<pre><code>device_pixel_ratio: float\n</code></pre> <p>The ratio between physical pixels and logical CSS pixels on the device.</p>"},{"location":"api/trace/#nodekit.events.BrowserContextSampledEvent.display","title":"display  <code>pydantic-field</code>","text":"<pre><code>display: RegionSizePx\n</code></pre> <p>The size of the Participant's display in physical pixels.</p>"},{"location":"api/trace/#nodekit.events.BrowserContextSampledEvent.timestamp_client","title":"timestamp_client  <code>pydantic-field</code>","text":"<pre><code>timestamp_client: str\n</code></pre> <p>The ISO8601-formatted timestamp that the Participant's browser disclosed at the time of this event.</p>"},{"location":"api/trace/#nodekit.events.BrowserContextSampledEvent.user_agent","title":"user_agent  <code>pydantic-field</code>","text":"<pre><code>user_agent: str\n</code></pre> <p>The user agent string of the browser.</p>"}]}