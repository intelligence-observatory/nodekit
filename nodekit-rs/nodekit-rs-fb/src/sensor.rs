// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::timer::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CLICK_SENSOR_MASK: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CLICK_SENSOR_MASK: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CLICK_SENSOR_MASK: [ClickSensorMask; 2] = [
  ClickSensorMask::Rectangle,
  ClickSensorMask::Ellipse,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ClickSensorMask(pub u8);
#[allow(non_upper_case_globals)]
impl ClickSensorMask {
  pub const Rectangle: Self = Self(1);
  pub const Ellipse: Self = Self(2);

  pub const ENUM_MIN: u8 = 1;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Rectangle,
    Self::Ellipse,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Rectangle => Some("Rectangle"),
      Self::Ellipse => Some("Ellipse"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ClickSensorMask {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ClickSensorMask {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ClickSensorMask {
    type Output = ClickSensorMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ClickSensorMask {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ClickSensorMask {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ClickSensorMask {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEMPORALLY_BOUNDED_SENSOR_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEMPORALLY_BOUNDED_SENSOR_TYPE: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEMPORALLY_BOUNDED_SENSOR_TYPE: [TemporallyBoundedSensorType; 4] = [
  TemporallyBoundedSensorType::NONE,
  TemporallyBoundedSensorType::ClickSensor,
  TemporallyBoundedSensorType::KeySensor,
  TemporallyBoundedSensorType::SubmitSensor,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TemporallyBoundedSensorType(pub u8);
#[allow(non_upper_case_globals)]
impl TemporallyBoundedSensorType {
  pub const NONE: Self = Self(0);
  pub const ClickSensor: Self = Self(1);
  pub const KeySensor: Self = Self(2);
  pub const SubmitSensor: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ClickSensor,
    Self::KeySensor,
    Self::SubmitSensor,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ClickSensor => Some("ClickSensor"),
      Self::KeySensor => Some("KeySensor"),
      Self::SubmitSensor => Some("SubmitSensor"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TemporallyBoundedSensorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TemporallyBoundedSensorType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for TemporallyBoundedSensorType {
    type Output = TemporallyBoundedSensorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for TemporallyBoundedSensorType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TemporallyBoundedSensorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TemporallyBoundedSensorType {}
pub struct TemporallyBoundedSensorTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SENSOR_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SENSOR_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SENSOR_TYPE: [SensorType; 3] = [
  SensorType::NONE,
  SensorType::TemporallyBoundedSensor,
  SensorType::TimeoutSensor,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SensorType(pub u8);
#[allow(non_upper_case_globals)]
impl SensorType {
  pub const NONE: Self = Self(0);
  pub const TemporallyBoundedSensor: Self = Self(1);
  pub const TimeoutSensor: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::TemporallyBoundedSensor,
    Self::TimeoutSensor,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::TemporallyBoundedSensor => Some("TemporallyBoundedSensor"),
      Self::TimeoutSensor => Some("TimeoutSensor"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SensorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SensorType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for SensorType {
    type Output = SensorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for SensorType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SensorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SensorType {}
pub struct SensorTypeUnionTableOffset {}

pub enum ClickSensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClickSensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClickSensor<'a> {
  type Inner = ClickSensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ClickSensor<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_W: flatbuffers::VOffsetT = 8;
  pub const VT_H: flatbuffers::VOffsetT = 10;
  pub const VT_MASK: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClickSensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ClickSensorArgs
  ) -> flatbuffers::WIPOffset<ClickSensor<'bldr>> {
    let mut builder = ClickSensorBuilder::new(_fbb);
    builder.add_h(args.h);
    builder.add_w(args.w);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.add_mask(args.mask);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ClickSensor::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ClickSensor::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn w(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ClickSensor::VT_W, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn h(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ClickSensor::VT_H, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn mask(&self) -> ClickSensorMask {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ClickSensorMask>(ClickSensor::VT_MASK, Some(ClickSensorMask::Rectangle)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ClickSensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x", Self::VT_X, false)?
     .visit_field::<f32>("y", Self::VT_Y, false)?
     .visit_field::<f32>("w", Self::VT_W, false)?
     .visit_field::<f32>("h", Self::VT_H, false)?
     .visit_field::<ClickSensorMask>("mask", Self::VT_MASK, false)?
     .finish();
    Ok(())
  }
}
pub struct ClickSensorArgs {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub mask: ClickSensorMask,
}
impl<'a> Default for ClickSensorArgs {
  #[inline]
  fn default() -> Self {
    ClickSensorArgs {
      x: 0.0,
      y: 0.0,
      w: 0.0,
      h: 0.0,
      mask: ClickSensorMask::Rectangle,
    }
  }
}

pub struct ClickSensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClickSensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(ClickSensor::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(ClickSensor::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_w(&mut self, w: f32) {
    self.fbb_.push_slot::<f32>(ClickSensor::VT_W, w, 0.0);
  }
  #[inline]
  pub fn add_h(&mut self, h: f32) {
    self.fbb_.push_slot::<f32>(ClickSensor::VT_H, h, 0.0);
  }
  #[inline]
  pub fn add_mask(&mut self, mask: ClickSensorMask) {
    self.fbb_.push_slot::<ClickSensorMask>(ClickSensor::VT_MASK, mask, ClickSensorMask::Rectangle);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ClickSensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ClickSensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClickSensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClickSensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClickSensor");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("w", &self.w());
      ds.field("h", &self.h());
      ds.field("mask", &self.mask());
      ds.finish()
  }
}
pub enum KeySensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeySensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeySensor<'a> {
  type Inner = KeySensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> KeySensor<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeySensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeySensorArgs<'args>
  ) -> flatbuffers::WIPOffset<KeySensor<'bldr>> {
    let mut builder = KeySensorBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeySensor::VT_KEY, None)}
  }
}

impl flatbuffers::Verifiable for KeySensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct KeySensorArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KeySensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeySensorArgs {
      key: None,
    }
  }
}

pub struct KeySensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeySensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeySensor::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeySensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeySensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeySensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeySensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeySensor");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum SubmitSensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubmitSensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubmitSensor<'a> {
  type Inner = SubmitSensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SubmitSensor<'a> {
  pub const VT_SUBMITTER_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE_IDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubmitSensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubmitSensorArgs<'args>
  ) -> flatbuffers::WIPOffset<SubmitSensor<'bldr>> {
    let mut builder = SubmitSensorBuilder::new(_fbb);
    if let Some(x) = args.source_ids { builder.add_source_ids(x); }
    if let Some(x) = args.submitter_id { builder.add_submitter_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn submitter_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubmitSensor::VT_SUBMITTER_ID, None)}
  }
  #[inline]
  pub fn source_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SubmitSensor::VT_SOURCE_IDS, None)}
  }
}

impl flatbuffers::Verifiable for SubmitSensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("submitter_id", Self::VT_SUBMITTER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("source_ids", Self::VT_SOURCE_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SubmitSensorArgs<'a> {
    pub submitter_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SubmitSensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubmitSensorArgs {
      submitter_id: None,
      source_ids: None,
    }
  }
}

pub struct SubmitSensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubmitSensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_submitter_id(&mut self, submitter_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubmitSensor::VT_SUBMITTER_ID, submitter_id);
  }
  #[inline]
  pub fn add_source_ids(&mut self, source_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubmitSensor::VT_SOURCE_IDS, source_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SubmitSensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubmitSensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubmitSensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubmitSensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubmitSensor");
      ds.field("submitter_id", &self.submitter_id());
      ds.field("source_ids", &self.source_ids());
      ds.finish()
  }
}
pub enum TemporallyBoundedSensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TemporallyBoundedSensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TemporallyBoundedSensor<'a> {
  type Inner = TemporallyBoundedSensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TemporallyBoundedSensor<'a> {
  pub const VT_SENSOR_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SENSOR: flatbuffers::VOffsetT = 6;
  pub const VT_TIMER: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TemporallyBoundedSensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TemporallyBoundedSensorArgs<'args>
  ) -> flatbuffers::WIPOffset<TemporallyBoundedSensor<'bldr>> {
    let mut builder = TemporallyBoundedSensorBuilder::new(_fbb);
    if let Some(x) = args.timer { builder.add_timer(x); }
    if let Some(x) = args.sensor { builder.add_sensor(x); }
    builder.add_sensor_type(args.sensor_type);
    builder.finish()
  }


  #[inline]
  pub fn sensor_type(&self) -> TemporallyBoundedSensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TemporallyBoundedSensorType>(TemporallyBoundedSensor::VT_SENSOR_TYPE, Some(TemporallyBoundedSensorType::NONE)).unwrap()}
  }
  #[inline]
  pub fn sensor(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(TemporallyBoundedSensor::VT_SENSOR, None)}
  }
  #[inline]
  pub fn timer(&self) -> Option<Timer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Timer>>(TemporallyBoundedSensor::VT_TIMER, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn sensor_as_click_sensor(&self) -> Option<ClickSensor<'a>> {
    if self.sensor_type() == TemporallyBoundedSensorType::ClickSensor {
      self.sensor().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ClickSensor::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn sensor_as_key_sensor(&self) -> Option<KeySensor<'a>> {
    if self.sensor_type() == TemporallyBoundedSensorType::KeySensor {
      self.sensor().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { KeySensor::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn sensor_as_submit_sensor(&self) -> Option<SubmitSensor<'a>> {
    if self.sensor_type() == TemporallyBoundedSensorType::SubmitSensor {
      self.sensor().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SubmitSensor::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for TemporallyBoundedSensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<TemporallyBoundedSensorType, _>("sensor_type", Self::VT_SENSOR_TYPE, "sensor", Self::VT_SENSOR, false, |key, v, pos| {
        match key {
          TemporallyBoundedSensorType::ClickSensor => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ClickSensor>>("TemporallyBoundedSensorType::ClickSensor", pos),
          TemporallyBoundedSensorType::KeySensor => v.verify_union_variant::<flatbuffers::ForwardsUOffset<KeySensor>>("TemporallyBoundedSensorType::KeySensor", pos),
          TemporallyBoundedSensorType::SubmitSensor => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubmitSensor>>("TemporallyBoundedSensorType::SubmitSensor", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<Timer>>("timer", Self::VT_TIMER, false)?
     .finish();
    Ok(())
  }
}
pub struct TemporallyBoundedSensorArgs<'a> {
    pub sensor_type: TemporallyBoundedSensorType,
    pub sensor: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub timer: Option<flatbuffers::WIPOffset<Timer<'a>>>,
}
impl<'a> Default for TemporallyBoundedSensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    TemporallyBoundedSensorArgs {
      sensor_type: TemporallyBoundedSensorType::NONE,
      sensor: None,
      timer: None,
    }
  }
}

pub struct TemporallyBoundedSensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TemporallyBoundedSensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sensor_type(&mut self, sensor_type: TemporallyBoundedSensorType) {
    self.fbb_.push_slot::<TemporallyBoundedSensorType>(TemporallyBoundedSensor::VT_SENSOR_TYPE, sensor_type, TemporallyBoundedSensorType::NONE);
  }
  #[inline]
  pub fn add_sensor(&mut self, sensor: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TemporallyBoundedSensor::VT_SENSOR, sensor);
  }
  #[inline]
  pub fn add_timer(&mut self, timer: flatbuffers::WIPOffset<Timer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Timer>>(TemporallyBoundedSensor::VT_TIMER, timer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TemporallyBoundedSensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TemporallyBoundedSensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TemporallyBoundedSensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TemporallyBoundedSensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TemporallyBoundedSensor");
      ds.field("sensor_type", &self.sensor_type());
      match self.sensor_type() {
        TemporallyBoundedSensorType::ClickSensor => {
          if let Some(x) = self.sensor_as_click_sensor() {
            ds.field("sensor", &x)
          } else {
            ds.field("sensor", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        TemporallyBoundedSensorType::KeySensor => {
          if let Some(x) = self.sensor_as_key_sensor() {
            ds.field("sensor", &x)
          } else {
            ds.field("sensor", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        TemporallyBoundedSensorType::SubmitSensor => {
          if let Some(x) = self.sensor_as_submit_sensor() {
            ds.field("sensor", &x)
          } else {
            ds.field("sensor", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("sensor", &x)
        },
      };
      ds.field("timer", &self.timer());
      ds.finish()
  }
}
pub enum TimeoutSensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TimeoutSensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimeoutSensor<'a> {
  type Inner = TimeoutSensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TimeoutSensor<'a> {
  pub const VT_TIMEOUT_MSEC: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TimeoutSensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TimeoutSensorArgs
  ) -> flatbuffers::WIPOffset<TimeoutSensor<'bldr>> {
    let mut builder = TimeoutSensorBuilder::new(_fbb);
    builder.add_timeout_msec(args.timeout_msec);
    builder.finish()
  }


  #[inline]
  pub fn timeout_msec(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TimeoutSensor::VT_TIMEOUT_MSEC, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TimeoutSensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("timeout_msec", Self::VT_TIMEOUT_MSEC, false)?
     .finish();
    Ok(())
  }
}
pub struct TimeoutSensorArgs {
    pub timeout_msec: i32,
}
impl<'a> Default for TimeoutSensorArgs {
  #[inline]
  fn default() -> Self {
    TimeoutSensorArgs {
      timeout_msec: 0,
    }
  }
}

pub struct TimeoutSensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TimeoutSensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_timeout_msec(&mut self, timeout_msec: i32) {
    self.fbb_.push_slot::<i32>(TimeoutSensor::VT_TIMEOUT_MSEC, timeout_msec, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TimeoutSensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TimeoutSensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimeoutSensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TimeoutSensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TimeoutSensor");
      ds.field("timeout_msec", &self.timeout_msec());
      ds.finish()
  }
}
pub enum SensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Sensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sensor<'a> {
  type Inner = Sensor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Sensor<'a> {
  pub const VT_SENSOR_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SENSOR_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Sensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SensorArgs<'args>
  ) -> flatbuffers::WIPOffset<Sensor<'bldr>> {
    let mut builder = SensorBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.sensor_type { builder.add_sensor_type(x); }
    builder.add_sensor_type_type(args.sensor_type_type);
    builder.finish()
  }


  #[inline]
  pub fn sensor_type_type(&self) -> SensorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SensorType>(Sensor::VT_SENSOR_TYPE_TYPE, Some(SensorType::NONE)).unwrap()}
  }
  #[inline]
  pub fn sensor_type(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Sensor::VT_SENSOR_TYPE, None)}
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sensor::VT_ID, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn sensor_type_as_temporally_bounded_sensor(&self) -> Option<TemporallyBoundedSensor<'a>> {
    if self.sensor_type_type() == SensorType::TemporallyBoundedSensor {
      self.sensor_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TemporallyBoundedSensor::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn sensor_type_as_timeout_sensor(&self) -> Option<TimeoutSensor<'a>> {
    if self.sensor_type_type() == SensorType::TimeoutSensor {
      self.sensor_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TimeoutSensor::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Sensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<SensorType, _>("sensor_type_type", Self::VT_SENSOR_TYPE_TYPE, "sensor_type", Self::VT_SENSOR_TYPE, false, |key, v, pos| {
        match key {
          SensorType::TemporallyBoundedSensor => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TemporallyBoundedSensor>>("SensorType::TemporallyBoundedSensor", pos),
          SensorType::TimeoutSensor => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimeoutSensor>>("SensorType::TimeoutSensor", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct SensorArgs<'a> {
    pub sensor_type_type: SensorType,
    pub sensor_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    SensorArgs {
      sensor_type_type: SensorType::NONE,
      sensor_type: None,
      id: None,
    }
  }
}

pub struct SensorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SensorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sensor_type_type(&mut self, sensor_type_type: SensorType) {
    self.fbb_.push_slot::<SensorType>(Sensor::VT_SENSOR_TYPE_TYPE, sensor_type_type, SensorType::NONE);
  }
  #[inline]
  pub fn add_sensor_type(&mut self, sensor_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensor::VT_SENSOR_TYPE, sensor_type);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sensor::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SensorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Sensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Sensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Sensor");
      ds.field("sensor_type_type", &self.sensor_type_type());
      match self.sensor_type_type() {
        SensorType::TemporallyBoundedSensor => {
          if let Some(x) = self.sensor_type_as_temporally_bounded_sensor() {
            ds.field("sensor_type", &x)
          } else {
            ds.field("sensor_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SensorType::TimeoutSensor => {
          if let Some(x) = self.sensor_type_as_timeout_sensor() {
            ds.field("sensor_type", &x)
          } else {
            ds.field("sensor_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("sensor_type", &x)
        },
      };
      ds.field("id", &self.id());
      ds.finish()
  }
}
