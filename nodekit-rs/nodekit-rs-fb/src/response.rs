// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_STATE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_STATE: u8 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATE: [State; 5] = [
    State::Pending,
    State::StartedNow,
    State::Active,
    State::EndedNow,
    State::Finished,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct State(pub u8);
#[allow(non_upper_case_globals)]
impl State {
    pub const Pending: Self = Self(1);
    pub const StartedNow: Self = Self(2);
    pub const Active: Self = Self(3);
    pub const EndedNow: Self = Self(4);
    pub const Finished: Self = Self(5);

    pub const ENUM_MIN: u8 = 1;
    pub const ENUM_MAX: u8 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Pending,
        Self::StartedNow,
        Self::Active,
        Self::EndedNow,
        Self::Finished,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Pending => Some("Pending"),
            Self::StartedNow => Some("StartedNow"),
            Self::Active => Some("Active"),
            Self::EndedNow => Some("EndedNow"),
            Self::Finished => Some("Finished"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for State {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for State {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for State {
    type Output = State;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for State {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for State {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for State {}
pub enum ResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Response<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Response<'a> {
    type Inner = Response<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> Response<'a> {
    pub const VT_BOARD: flatbuffers::VOffsetT = 4;
    pub const VT_AUDIO: flatbuffers::VOffsetT = 6;
    pub const VT_SENSOR: flatbuffers::VOffsetT = 8;
    pub const VT_STATE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Response { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ResponseArgs<'args>,
    ) -> flatbuffers::WIPOffset<Response<'bldr>> {
        let mut builder = ResponseBuilder::new(_fbb);
        if let Some(x) = args.sensor {
            builder.add_sensor(x);
        }
        if let Some(x) = args.audio {
            builder.add_audio(x);
        }
        if let Some(x) = args.board {
            builder.add_board(x);
        }
        builder.add_state(args.state);
        builder.finish()
    }

    #[inline]
    pub fn board(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Response::VT_BOARD,
                    None,
                )
        }
    }
    #[inline]
    pub fn audio(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Response::VT_AUDIO,
                    None,
                )
        }
    }
    #[inline]
    pub fn sensor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Response::VT_SENSOR, None)
        }
    }
    #[inline]
    pub fn state(&self) -> State {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<State>(Response::VT_STATE, Some(State::Pending))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Response<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "board",
                Self::VT_BOARD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "audio",
                Self::VT_AUDIO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sensor", Self::VT_SENSOR, false)?
            .visit_field::<State>("state", Self::VT_STATE, false)?
            .finish();
        Ok(())
    }
}
pub struct ResponseArgs<'a> {
    pub board: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub audio: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub sensor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub state: State,
}
impl<'a> Default for ResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        ResponseArgs {
            board: None,
            audio: None,
            sensor: None,
            state: State::Pending,
        }
    }
}

pub struct ResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResponseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_board(&mut self, board: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Response::VT_BOARD, board);
    }
    #[inline]
    pub fn add_audio(&mut self, audio: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Response::VT_AUDIO, audio);
    }
    #[inline]
    pub fn add_sensor(&mut self, sensor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Response::VT_SENSOR, sensor);
    }
    #[inline]
    pub fn add_state(&mut self, state: State) {
        self.fbb_
            .push_slot::<State>(Response::VT_STATE, state, State::Pending);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ResponseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ResponseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Response<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Response<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Response");
        ds.field("board", &self.board());
        ds.field("audio", &self.audio());
        ds.field("sensor", &self.sensor());
        ds.field("state", &self.state());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Response`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn root_as_response(buf: &[u8]) -> Result<Response, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Response>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Response` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_response_unchecked`.
pub fn size_prefixed_root_as_response(
    buf: &[u8],
) -> Result<Response, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Response>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Response` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn root_as_response_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Response<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Response<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Response` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn size_prefixed_root_as_response_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Response<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Response<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Response and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Response`.
pub unsafe fn root_as_response_unchecked(buf: &[u8]) -> Response {
    unsafe { flatbuffers::root_unchecked::<Response>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Response and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Response`.
pub unsafe fn size_prefixed_root_as_response_unchecked(buf: &[u8]) -> Response {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<Response>(buf) }
}
pub const RESPONSE_IDENTIFIER: &str = "repl";

#[inline]
pub fn response_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, RESPONSE_IDENTIFIER, false)
}

#[inline]
pub fn response_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, RESPONSE_IDENTIFIER, true)
}

#[inline]
pub fn finish_response_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Response<'a>>,
) {
    fbb.finish(root, Some(RESPONSE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_response_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Response<'a>>,
) {
    fbb.finish_size_prefixed(root, Some(RESPONSE_IDENTIFIER));
}
