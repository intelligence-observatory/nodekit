// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_LOCATOR: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_LOCATOR: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LOCATOR: [Locator; 3] =
    [Locator::NONE, Locator::Path, Locator::ZipArchivePath];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Locator(pub u8);
#[allow(non_upper_case_globals)]
impl Locator {
    pub const NONE: Self = Self(0);
    pub const Path: Self = Self(1);
    pub const ZipArchivePath: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::Path, Self::ZipArchivePath];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::Path => Some("Path"),
            Self::ZipArchivePath => Some("ZipArchivePath"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Locator {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Locator {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for Locator {
    type Output = Locator;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for Locator {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Locator {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Locator {}
pub struct LocatorUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MEDIA_TYPE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MEDIA_TYPE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MEDIA_TYPE: [MediaType; 2] = [MediaType::Image, MediaType::Video];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MediaType(pub u8);
#[allow(non_upper_case_globals)]
impl MediaType {
    pub const Image: Self = Self(1);
    pub const Video: Self = Self(2);

    pub const ENUM_MIN: u8 = 1;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Image, Self::Video];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Image => Some("Image"),
            Self::Video => Some("Video"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MediaType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MediaType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for MediaType {
    type Output = MediaType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for MediaType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MediaType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MediaType {}
pub enum PathOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Path<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Path<'a> {
    type Inner = Path<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> Path<'a> {
    pub const VT_PATH: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Path { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PathArgs<'args>,
    ) -> flatbuffers::WIPOffset<Path<'bldr>> {
        let mut builder = PathBuilder::new(_fbb);
        if let Some(x) = args.path {
            builder.add_path(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Path::VT_PATH, None)
        }
    }
}

impl flatbuffers::Verifiable for Path<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
            .finish();
        Ok(())
    }
}
pub struct PathArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PathArgs<'a> {
    #[inline]
    fn default() -> Self {
        PathArgs { path: None }
    }
}

pub struct PathBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PathBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Path::VT_PATH, path);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PathBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PathBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Path<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Path<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Path");
        ds.field("path", &self.path());
        ds.finish()
    }
}
pub enum ZipArchivePathOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZipArchivePath<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZipArchivePath<'a> {
    type Inner = ZipArchivePath<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> ZipArchivePath<'a> {
    pub const VT_ZIP_ARCHIVE_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_INNER_PATH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ZipArchivePath { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ZipArchivePathArgs<'args>,
    ) -> flatbuffers::WIPOffset<ZipArchivePath<'bldr>> {
        let mut builder = ZipArchivePathBuilder::new(_fbb);
        if let Some(x) = args.inner_path {
            builder.add_inner_path(x);
        }
        if let Some(x) = args.zip_archive_path {
            builder.add_zip_archive_path(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn zip_archive_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                ZipArchivePath::VT_ZIP_ARCHIVE_PATH,
                None,
            )
        }
    }
    #[inline]
    pub fn inner_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ZipArchivePath::VT_INNER_PATH, None)
        }
    }
}

impl flatbuffers::Verifiable for ZipArchivePath<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zip_archive_path",
                Self::VT_ZIP_ARCHIVE_PATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "inner_path",
                Self::VT_INNER_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ZipArchivePathArgs<'a> {
    pub zip_archive_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inner_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ZipArchivePathArgs<'a> {
    #[inline]
    fn default() -> Self {
        ZipArchivePathArgs {
            zip_archive_path: None,
            inner_path: None,
        }
    }
}

pub struct ZipArchivePathBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZipArchivePathBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zip_archive_path(&mut self, zip_archive_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ZipArchivePath::VT_ZIP_ARCHIVE_PATH,
            zip_archive_path,
        );
    }
    #[inline]
    pub fn add_inner_path(&mut self, inner_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ZipArchivePath::VT_INNER_PATH,
            inner_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ZipArchivePathBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ZipArchivePathBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ZipArchivePath<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ZipArchivePath<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ZipArchivePath");
        ds.field("zip_archive_path", &self.zip_archive_path());
        ds.field("inner_path", &self.inner_path());
        ds.finish()
    }
}
pub enum AssetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Asset<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Asset<'a> {
    type Inner = Asset<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> Asset<'a> {
    pub const VT_LOCATOR_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_LOCATOR: flatbuffers::VOffsetT = 6;
    pub const VT_MEDIA_TYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Asset { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AssetArgs,
    ) -> flatbuffers::WIPOffset<Asset<'bldr>> {
        let mut builder = AssetBuilder::new(_fbb);
        if let Some(x) = args.locator {
            builder.add_locator(x);
        }
        builder.add_media_type(args.media_type);
        builder.add_locator_type(args.locator_type);
        builder.finish()
    }

    #[inline]
    pub fn locator_type(&self) -> Locator {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Locator>(Asset::VT_LOCATOR_TYPE, Some(Locator::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn locator(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    Asset::VT_LOCATOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn media_type(&self) -> MediaType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MediaType>(Asset::VT_MEDIA_TYPE, Some(MediaType::Image))
                .unwrap()
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn locator_as_path(&self) -> Option<Path<'a>> {
        if self.locator_type() == Locator::Path {
            self.locator().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Path::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn locator_as_zip_archive_path(&self) -> Option<ZipArchivePath<'a>> {
        if self.locator_type() == Locator::ZipArchivePath {
            self.locator().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ZipArchivePath::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Asset<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<Locator, _>(
                "locator_type",
                Self::VT_LOCATOR_TYPE,
                "locator",
                Self::VT_LOCATOR,
                false,
                |key, v, pos| match key {
                    Locator::Path => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Path>>(
                        "Locator::Path",
                        pos,
                    ),
                    Locator::ZipArchivePath => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ZipArchivePath>>(
                            "Locator::ZipArchivePath",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<MediaType>("media_type", Self::VT_MEDIA_TYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct AssetArgs {
    pub locator_type: Locator,
    pub locator: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub media_type: MediaType,
}
impl<'a> Default for AssetArgs {
    #[inline]
    fn default() -> Self {
        AssetArgs {
            locator_type: Locator::NONE,
            locator: None,
            media_type: MediaType::Image,
        }
    }
}

pub struct AssetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssetBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_locator_type(&mut self, locator_type: Locator) {
        self.fbb_
            .push_slot::<Locator>(Asset::VT_LOCATOR_TYPE, locator_type, Locator::NONE);
    }
    #[inline]
    pub fn add_locator(&mut self, locator: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Asset::VT_LOCATOR, locator);
    }
    #[inline]
    pub fn add_media_type(&mut self, media_type: MediaType) {
        self.fbb_
            .push_slot::<MediaType>(Asset::VT_MEDIA_TYPE, media_type, MediaType::Image);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AssetBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AssetBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Asset<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Asset<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Asset");
        ds.field("locator_type", &self.locator_type());
        match self.locator_type() {
            Locator::Path => {
                if let Some(x) = self.locator_as_path() {
                    ds.field("locator", &x)
                } else {
                    ds.field(
                        "locator",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Locator::ZipArchivePath => {
                if let Some(x) = self.locator_as_zip_archive_path() {
                    ds.field("locator", &x)
                } else {
                    ds.field(
                        "locator",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("locator", &x)
            }
        };
        ds.field("media_type", &self.media_type());
        ds.finish()
    }
}
