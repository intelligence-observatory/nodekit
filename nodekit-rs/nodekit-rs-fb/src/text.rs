// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_JUSTIFICATION_HORIZONTAL: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_JUSTIFICATION_HORIZONTAL: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_JUSTIFICATION_HORIZONTAL: [JustificationHorizontal; 3] = [
    JustificationHorizontal::Left,
    JustificationHorizontal::Center,
    JustificationHorizontal::Right,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct JustificationHorizontal(pub u8);
#[allow(non_upper_case_globals)]
impl JustificationHorizontal {
    pub const Left: Self = Self(1);
    pub const Center: Self = Self(2);
    pub const Right: Self = Self(3);

    pub const ENUM_MIN: u8 = 1;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Left, Self::Center, Self::Right];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Left => Some("Left"),
            Self::Center => Some("Center"),
            Self::Right => Some("Right"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for JustificationHorizontal {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for JustificationHorizontal {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for JustificationHorizontal {
    type Output = JustificationHorizontal;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for JustificationHorizontal {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for JustificationHorizontal {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for JustificationHorizontal {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_JUSTIFICATION_VERTICAL: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_JUSTIFICATION_VERTICAL: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_JUSTIFICATION_VERTICAL: [JustificationVertical; 3] = [
    JustificationVertical::Top,
    JustificationVertical::Center,
    JustificationVertical::Bottom,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct JustificationVertical(pub u8);
#[allow(non_upper_case_globals)]
impl JustificationVertical {
    pub const Top: Self = Self(1);
    pub const Center: Self = Self(2);
    pub const Bottom: Self = Self(3);

    pub const ENUM_MIN: u8 = 1;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Top, Self::Center, Self::Bottom];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Top => Some("Top"),
            Self::Center => Some("Center"),
            Self::Bottom => Some("Bottom"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for JustificationVertical {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for JustificationVertical {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for JustificationVertical {
    type Output = JustificationVertical;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for JustificationVertical {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for JustificationVertical {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for JustificationVertical {}
pub enum TextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Text<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Text<'a> {
    type Inner = Text<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> Text<'a> {
    pub const VT_TEXT: flatbuffers::VOffsetT = 4;
    pub const VT_FONT_SIZE: flatbuffers::VOffsetT = 6;
    pub const VT_JUSTIFICATION_HORIZONTAL: flatbuffers::VOffsetT = 8;
    pub const VT_JUSTIFICATION_VERTICAL: flatbuffers::VOffsetT = 10;
    pub const VT_BACKGROUND_COLOR: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Text { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TextArgs<'args>,
    ) -> flatbuffers::WIPOffset<Text<'bldr>> {
        let mut builder = TextBuilder::new(_fbb);
        if let Some(x) = args.background_color {
            builder.add_background_color(x);
        }
        builder.add_font_size(args.font_size);
        if let Some(x) = args.text {
            builder.add_text(x);
        }
        builder.add_justification_vertical(args.justification_vertical);
        builder.add_justification_horizontal(args.justification_horizontal);
        builder.finish()
    }

    #[inline]
    pub fn text(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Text::VT_TEXT, None)
        }
    }
    #[inline]
    pub fn font_size(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(Text::VT_FONT_SIZE, Some(0.0)).unwrap() }
    }
    #[inline]
    pub fn justification_horizontal(&self) -> JustificationHorizontal {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<JustificationHorizontal>(
                    Text::VT_JUSTIFICATION_HORIZONTAL,
                    Some(JustificationHorizontal::Left),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn justification_vertical(&self) -> JustificationVertical {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<JustificationVertical>(
                    Text::VT_JUSTIFICATION_VERTICAL,
                    Some(JustificationVertical::Top),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn background_color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Text::VT_BACKGROUND_COLOR, None)
        }
    }
}

impl flatbuffers::Verifiable for Text<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
            .visit_field::<f32>("font_size", Self::VT_FONT_SIZE, false)?
            .visit_field::<JustificationHorizontal>(
                "justification_horizontal",
                Self::VT_JUSTIFICATION_HORIZONTAL,
                false,
            )?
            .visit_field::<JustificationVertical>(
                "justification_vertical",
                Self::VT_JUSTIFICATION_VERTICAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "background_color",
                Self::VT_BACKGROUND_COLOR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TextArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub font_size: f32,
    pub justification_horizontal: JustificationHorizontal,
    pub justification_vertical: JustificationVertical,
    pub background_color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TextArgs<'a> {
    #[inline]
    fn default() -> Self {
        TextArgs {
            text: None,
            font_size: 0.0,
            justification_horizontal: JustificationHorizontal::Left,
            justification_vertical: JustificationVertical::Top,
            background_color: None,
        }
    }
}

pub struct TextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Text::VT_TEXT, text);
    }
    #[inline]
    pub fn add_font_size(&mut self, font_size: f32) {
        self.fbb_
            .push_slot::<f32>(Text::VT_FONT_SIZE, font_size, 0.0);
    }
    #[inline]
    pub fn add_justification_horizontal(
        &mut self,
        justification_horizontal: JustificationHorizontal,
    ) {
        self.fbb_.push_slot::<JustificationHorizontal>(
            Text::VT_JUSTIFICATION_HORIZONTAL,
            justification_horizontal,
            JustificationHorizontal::Left,
        );
    }
    #[inline]
    pub fn add_justification_vertical(&mut self, justification_vertical: JustificationVertical) {
        self.fbb_.push_slot::<JustificationVertical>(
            Text::VT_JUSTIFICATION_VERTICAL,
            justification_vertical,
            JustificationVertical::Top,
        );
    }
    #[inline]
    pub fn add_background_color(&mut self, background_color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Text::VT_BACKGROUND_COLOR,
            background_color,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Text<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Text<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Text");
        ds.field("text", &self.text());
        ds.field("font_size", &self.font_size());
        ds.field("justification_horizontal", &self.justification_horizontal());
        ds.field("justification_vertical", &self.justification_vertical());
        ds.field("background_color", &self.background_color());
        ds.finish()
    }
}
