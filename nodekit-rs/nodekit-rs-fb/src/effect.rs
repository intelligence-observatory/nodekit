// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use crate::timer::*;
use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_EFFECT_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_EFFECT_TYPE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EFFECT_TYPE: [EffectType; 2] =
    [EffectType::NONE, EffectType::HidePointerEffect];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EffectType(pub u8);
#[allow(non_upper_case_globals)]
impl EffectType {
    pub const NONE: Self = Self(0);
    pub const HidePointerEffect: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::HidePointerEffect];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HidePointerEffect => Some("HidePointerEffect"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for EffectType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for EffectType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for EffectType {
    type Output = EffectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for EffectType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for EffectType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for EffectType {}
pub struct EffectTypeUnionTableOffset {}

pub enum HidePointerEffectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HidePointerEffect<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HidePointerEffect<'a> {
    type Inner = HidePointerEffect<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> HidePointerEffect<'a> {
    pub const VT_END_MSEC: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HidePointerEffect { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args HidePointerEffectArgs,
    ) -> flatbuffers::WIPOffset<HidePointerEffect<'bldr>> {
        let mut builder = HidePointerEffectBuilder::new(_fbb);
        builder.add_end_msec(args.end_msec);
        builder.finish()
    }

    #[inline]
    pub fn end_msec(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(HidePointerEffect::VT_END_MSEC, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for HidePointerEffect<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("end_msec", Self::VT_END_MSEC, false)?
            .finish();
        Ok(())
    }
}
pub struct HidePointerEffectArgs {
    pub end_msec: i32,
}
impl<'a> Default for HidePointerEffectArgs {
    #[inline]
    fn default() -> Self {
        HidePointerEffectArgs { end_msec: 0 }
    }
}

pub struct HidePointerEffectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HidePointerEffectBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_end_msec(&mut self, end_msec: i32) {
        self.fbb_
            .push_slot::<i32>(HidePointerEffect::VT_END_MSEC, end_msec, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> HidePointerEffectBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        HidePointerEffectBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HidePointerEffect<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HidePointerEffect<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HidePointerEffect");
        ds.field("end_msec", &self.end_msec());
        ds.finish()
    }
}
pub enum EffectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Effect<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Effect<'a> {
    type Inner = Effect<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> Effect<'a> {
    pub const VT_EFFECT_TYPE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_EFFECT_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TIMER: flatbuffers::VOffsetT = 8;
    pub const VT_ID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Effect { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args EffectArgs<'args>,
    ) -> flatbuffers::WIPOffset<Effect<'bldr>> {
        let mut builder = EffectBuilder::new(_fbb);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        if let Some(x) = args.timer {
            builder.add_timer(x);
        }
        if let Some(x) = args.effect_type {
            builder.add_effect_type(x);
        }
        builder.add_effect_type_type(args.effect_type_type);
        builder.finish()
    }

    #[inline]
    pub fn effect_type_type(&self) -> EffectType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<EffectType>(Effect::VT_EFFECT_TYPE_TYPE, Some(EffectType::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn effect_type(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    Effect::VT_EFFECT_TYPE,
                    None,
                )
        }
    }
    #[inline]
    pub fn timer(&self) -> Option<Timer<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Timer>>(Effect::VT_TIMER, None)
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Effect::VT_ID, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn effect_type_as_hide_pointer_effect(&self) -> Option<HidePointerEffect<'a>> {
        if self.effect_type_type() == EffectType::HidePointerEffect {
            self.effect_type().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HidePointerEffect::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Effect<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<EffectType, _>(
                "effect_type_type",
                Self::VT_EFFECT_TYPE_TYPE,
                "effect_type",
                Self::VT_EFFECT_TYPE,
                false,
                |key, v, pos| match key {
                    EffectType::HidePointerEffect => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<HidePointerEffect>>(
                            "EffectType::HidePointerEffect",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Timer>>("timer", Self::VT_TIMER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .finish();
        Ok(())
    }
}
pub struct EffectArgs<'a> {
    pub effect_type_type: EffectType,
    pub effect_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub timer: Option<flatbuffers::WIPOffset<Timer<'a>>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EffectArgs<'a> {
    #[inline]
    fn default() -> Self {
        EffectArgs {
            effect_type_type: EffectType::NONE,
            effect_type: None,
            timer: None,
            id: None,
        }
    }
}

pub struct EffectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EffectBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_effect_type_type(&mut self, effect_type_type: EffectType) {
        self.fbb_.push_slot::<EffectType>(
            Effect::VT_EFFECT_TYPE_TYPE,
            effect_type_type,
            EffectType::NONE,
        );
    }
    #[inline]
    pub fn add_effect_type(
        &mut self,
        effect_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Effect::VT_EFFECT_TYPE, effect_type);
    }
    #[inline]
    pub fn add_timer(&mut self, timer: flatbuffers::WIPOffset<Timer<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Timer>>(Effect::VT_TIMER, timer);
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Effect::VT_ID, id);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EffectBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EffectBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Effect<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Effect<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Effect");
        ds.field("effect_type_type", &self.effect_type_type());
        match self.effect_type_type() {
            EffectType::HidePointerEffect => {
                if let Some(x) = self.effect_type_as_hide_pointer_effect() {
                    ds.field("effect_type", &x)
                } else {
                    ds.field(
                        "effect_type",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("effect_type", &x)
            }
        };
        ds.field("timer", &self.timer());
        ds.field("id", &self.id());
        ds.finish()
    }
}
